---
title: "Example application of the Cologne Protocol for the Early Neolithic of central Europe"
author: "M. Broich & R. Peters"
date: "11 March 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# package magrittr is needed to execude the used pipes
library("magrittr")

# Turn scientific notation off
options(scipen = 999)

```

## Introduction

This manual presents an example application of the **Cologne Protocol** published in *Schmidt et al. (accepted)*. It is based upon the `.R` files which are in the `code\` directory. If you want to apply the Cologne Protocol on your own data, we recommend you to use these files, as it is possible to individually adjust certain variables at the beginning of the `00_LEC.R` file. However, the code chunks shown in this manual originate from the mentioned `.R` files.

The manual describes the first two parts of the Cologne Protocol, which are a GIS-analysis of site distribution and the identifying of so-called Core Areas. The aim of this document is neither to explain the further steps of the Cologne Protocol nor the theoretical background. For these points please refer to the associated publication including the supplementary information.

The goal of the script is to carry out all steps of the first part of the Cologne Protocol in R. These are (cf. *Schmidt et al. accepted, table S2*):

1. **Calculating "Largest Empty Circle"**

    i) Creating of Voronoi Polygons
    ii) Extraction of Vertices
    iii) Aggregation of Verticies
    iv) Defining the Radius of the "Largest Empty Circle"

2. **Kriging**

    i) Preparation and Grid
    ii) Semivariogram
    iii) Kriging
    iv) Kriging Results

3. **Optimally Describing Isolines**

    i) Creating Contour Lines (Isolines)
    ii) Calculating the Area and Number of Sites per Ssoline
    iii) Selecting the "Optimally Describing Isoline"

4. **Data export**


## Dependencies

To run the code of the script several packages are needed. These dependencies are stored in the `deps.yaml` file. It is possible to load them manually or to use `automagic::install_deps_file()` function. If the package `automagic` is not installed, it is possible to intsall it with `install.packages("automagic")`.  
Furthermore the script was developed under R version 3.6.3.


## Sample Data

For this examplary application, we use a distribution map of the Early Neolithic Linear Pottery Culture (LBK) in Central Europe. The map is based on *Preuss (1998, Karte 1)* and available from the CRC 806 database (https://crc806db.uni-koeln.de/start/).

The distribution map can be loaded into R via URL: 

```{r load data}
# url_link of distribution map of Linear Pottery Culture
url_link <- "http://sfb806srv.uni-koeln.de/owsproxy.php?service=WFS&version=1.0.0&request=GetFeature&typeNames=geonode%3A_13_earlyneolithic_ce_sites_wgs84&outputFormat=csv"

# load date as a data.frame
sites <- read.csv(url(url_link))

# Conversion into SPDF
sites <- sp::SpatialPointsDataFrame(sp::SpatialPoints(
  cbind(sites$RECHTS, sites$HOCH)),
  sites,
  proj4string = CRS("+init=epsg:31467"))

# This is not a reprojection, but some function if the projection is not defined like this
sp::proj4string(sites) <- sp::CRS("+init=epsg:31467")

```

It is important to note, that cartesian coordinates (planar coord.) have to be used, because `rgeos::gDistance` will only accept planar coordinates. Especially Lat/Long-coordinates will cause a problem.

We can also plot the data:

```{r plot sites, echo=FALSE}
plot(sites@coords[, 1], sites@coords[, 2],
     main = "Early Neolithic sites in Central Europe",
     xlab = "[EPSG 31467]",
     ylab = NA)
```

## Largest Empty Circle

The "Largest Empty Circle" (LEC) or more precicely the radius/diameter of a LEC is a meassure of site distance. Every LEC has it's center at a vertix of a Voronoi polygon and exactly three sites are located on every periphery of a LEC. An illustartion can be found at *Zimmermann et al. (2004, Abb.5)*.  
To summarize, areas with larger site distances will be characterized by larger radii of LECs and, logically, areas with smaller site distances will be characterized by smaller radii of LECs.

### Creating of Voronoi polygons and Extraction of vertices

The first step is to calculate the voronoi polygons and to extract the vertices:

```{r voronoi, message=FALSE}

# calculate voronoi polygons
voronoi_vertices <- deldir::deldir(sites@coords[, 1],
                                   sites@coords[, 2]) %$%
  # extraction of vertices
  dirsgs

```

After the extraction of the vertices from the Voronoi polygons, they have to be prepared to enable a transformation into an spdf (SpatialPointsDataFrame):

```{r vertices preparation}
# rearrange voronoi_vertices in preparation for transformation into an spdf
voronoi_vertices <- rbind(setNames(voronoi_vertices[,c(1:2, 5, 7, 9)],
                                   c("x", "y", "ind", "bp", "thirdv")),
                          setNames(voronoi_vertices[,c(3:4, 6, 8, 10)],
                                   c("x", "y", "ind", "bp", "thirdv")))
```

Finally, it is possible to transform the vertices into an spdf. Please note that the projection is explicitly assigned to the newly created `vertices_spdf`, since we have found that otherwise problems can arise:

```{r vertices transformation}
# transformation of voronoi_vertices into an spdf
vertices_spdf <- sp::SpatialPointsDataFrame(coords = voronoi_vertices[1:2],
                                            data = voronoi_vertices[, 3:5])

# Ignore warining! It's not a reprojection. But some functions need this step.
sp::proj4string(vertices_spdf) <- sp::CRS("+init=epsg:31467")
```

### Aggregation of verticies

During the step of extracting the vertices we did not care about that some of them were dublicates. In addition, some of the vertices are located at the border of the working area, the so-called border points. These points create artifical site distances and it must be decided in indiviual cases if the border points should be deleted or not.  
In the present example application we have to remove the dublicates but we will keep the border points.

```{r vertices aggregation}

remove_border_points <- FALSE # Normally, this variable is defined in 00_LEC.R

# If Condition wether border points are removed or not
if(remove_border_points == TRUE){
# remove dublicates and border points
vertices_spdf <- sp::remove.duplicates(vertices_spdf) %>%
  {.[.[[2]] == FALSE, ]}
} else {
  # just remove dublicates
  vertices_spdf <- sp::remove.duplicates(vertices_spdf)  
}
```

### Defining the radius of the "Largest Empty Circle"

In the following step we calculate the distance between a vertex of a Voronoi polygon and its nearest site. This distance is the radius of a LEC and will be assigned to the corresponding vertex.

```{r radius LEC}
# calculate radius of LEC and add this information to vertices_spdf
vertices_spdf@data$radiusLEC <- rgeos::gDistance(sites,
                                                 vertices_spdf,
                                                 byid = TRUE) %>%
  apply(1, min)
```

Below you see a plot of the archaeological sites and the Voronoi polygons with their vertices. The problem of the border points becomes visible in this figure. They are created at the edge of the working area and thus do not reflect actual site distances.

```{r Voronoi plot, echo=FALSE}
par(xpd = TRUE) # plot legend outside 
plot(vertices_spdf@coords[,1], vertices_spdf@coords[,2],
     type = "n",
     asp = 1,
     main = "Sites and corresponding Voronoi diagram",
     xlab = NA,
     ylab = "[EPSG 31467]")
points(sites,
       pch = 20,
       col = "red")
points(vertices_spdf,
       pch = 20,
       col = "black",
       cex = 0.9)
plot(deldir::deldir(sites@coords[,1], sites@coords[,2]),
     wlines = "tess",
     wpoints = "none",
     number = FALSE,
     lty = 1,
     add = TRUE)
legend(x = 2800000, y = 5000000,
       legend = c("Archaeological sites", "Voronoi vertices", "Voronoi polygons"),
       pch = c(20, 20, NA),
       lty = c(NA, NA, 1),
       col = c("red", "black", "black"),
       merge = TRUE,
       bty = "n",
       bg = "transparent",
       horiz = TRUE)
```


## Kriging

The next part of this document will describe the used Kriging procedure to estimate site distances on a regular spaced grid within the working area. These estimated site distances form the basis of the creation of isolines.

### Preparation and Grid

For kriging we need a grid of evenly distributed points. The algorithm will estimate the site distance (radius LEC) at every point of the grid, based upon the available vertices and their values for the radius of the LEC. A general introduction to kriging can be found at *Hengel (2007)* including kriging in R.  
The grid spacing to be selected depends on various factors. The size of the working area or the regular distances between the archaeological sites are an important factor. In addition, the selected grid spacing will significantly influence the computing time required, because a shorter grid distance will create more points.  
For the current example we will create a grid with a spacing of 1000 m between each point. This is a comparable large spacing but the working area is spanning most of Central Europe, which is a quite large area.

```{r Grid}
# Create a grid for kriging
grid <- expand.grid(x = seq(as.integer(range(vertices_spdf@coords[, 1]))[1],
                            as.integer(range(vertices_spdf@coords[, 1]))[2],
                            by = 1000),
                    y = seq(as.integer(range(vertices_spdf@coords[, 2]))[1],
                            as.integer(range(vertices_spdf@coords[, 2]))[2],
                            by = 1000)) %>%
  {sp::SpatialPoints(coords = .[1:2], proj4string = sp::CRS("+init=epsg:31467"))}
```

The generated grid consits of `r length(grid@coords[, 1])` points, at which the radius of the LEC is estimated by kriging.

### Semivariogram

The kriging procedure requires a theoretical semivariogram, which is used to estimate the radii of the LEC at every point of the grid. To compute this theoritical semivariogram, we need to explore first a experimental semivariogram. At this point we will refer again to *Hengel (2007)* as we will give no introduction to kriging in general.  
Before we can inspect the experimental semivariogram we have to define a lag distance:

```{r lag distance}
# Define Bounding Box Diagonal
bbox_diag <- sp::spDists(t(vertices_spdf@bbox))[1, 2]

# Lagdistance = Bounding Box Diagonal / 250
lagdist <- bbox_diag/250
```

Now it is possible compute the experimental semivariogram:

```{r exp vario}
# Sample variogram
vertices_vario <- gstat::variogram(radiusLEC~1,
                                   vertices_spdf,
                                   width = lagdist)
```

With the help of the experimental semivariogram, which you can see below, we can compute a theoretical semivariogram.

```{r plot exp vario, echo=FALSE}
plot(vertices_vario)
```

Doing so, we will need to identify the first plateu of the experimental semivariogram. According to *Zimmermann et al. (2004, 52)* the sill value of the theoretical semivariogram should be fitted to the first plateau of the experimental semivariogram. Additionally, the nugget value should be set to zero.  
In the current example we will identify the first plateau automatically. Of course it is also possible to choose these values by hand.

```{r plateau}
# Identify first plateau for fitting theoretical variogram  
range.plateau <- vertices_vario %$%
  gamma %>%
  diff() %>%
  {vertices_vario[2][which.max(./.[1] < 0.1), ]}

sill.plateau <- vertices_vario$gamma[vertices_vario$dist == range.plateau]
```

Lastly, we have to choose a model for the fitting of the theoretical semivariogram. The function `gstat::show.vgm()` will show you all available models. We, however, recommend to use the exponential "Exp" or spherical "Sph" model.  
In the current example we will use a spherical Model:

```{r fitting vario}
# Fitting theoretical variogram
vertices_vario_fit <- gstat::fit.variogram(vertices_vario,
                                           gstat::vgm(nugget = 0,
                                                      model  = "Sph",
                                                      psill  = sill.plateau,
                                                      range  = range.plateau),
                                           fit.sills = FALSE,
                                           fit.ranges = FALSE)
```

Comparing the experimental and the theoretical variogram shows that we more or less archived a good fit.

```{r plot fitted vario, echo=FALSE}
# Zoom in on range and sill plateau (range and sill.platau + 20 %)
plot(vertices_vario,
     vertices_vario_fit,
     xlim = c(0, range.plateau+(range.plateau/100)*20),
     ylim = c(0, sill.plateau+(sill.plateau/100)*20))
```

### Kriging

Now we have every information for the kriging procedure. The only three variables we have to define are `nmin`, `nmax` and `maxdist` in the `gstat::krige()` function. `nmin` and `nmax` are in our case the minimum and maximum number of Voronoi vertices, which will be considered by the kriging algorithm. Furthermore, we define that only observations (vertices) within a range of half of the bounding box diagonal will be used (`maxdist`). These are the default values for the Cologne Protocol.

```{r kriging}
# Kriging
LEC_kriged <- gstat::krige(radiusLEC~1,
                           vertices_spdf,
                           grid,
                           model = vertices_vario_fit,
                           nmin = 3,
                           nmax = 10,
                           maxdist = bbox_diag/2,
                           debug.level = 0)
```

### Kriging Results

The results of the kriging procedure can be visualized by two plots. The first one shows the estimated radii of the LECs at every point of the created grid:

```{r krige results, echo=FALSE}
LEC_kriged %>% as.data.frame %>%
  ggplot2::ggplot(ggplot2::aes(x=x, y=y)) +  
  ggplot2::geom_tile(ggplot2::aes(fill=var1.pred))+
  ggplot2::coord_equal() +
  ggplot2::scale_fill_gradientn(colours = terrain.colors(255)) +
  ggplot2::theme_bw() +
  ggplot2::geom_point(data = as.data.frame(sites),
                      ggplot2::aes(x = coords.x1, y = coords.x2), shape=21, size=2, 
                      colour = "black", fill= "red", alpha=1/5)
```

The second shows the variance of the kriging results, which is a meassure of quality:

```{r kriging variance, echo=FALSE}
LEC_kriged %>% as.data.frame %>%
  ggplot2::ggplot(ggplot2::aes(x=x, y=y)) + 
  ggplot2::geom_tile(ggplot2::aes(fill=var1.var)) + 
  ggplot2::coord_equal() +
  ggplot2::scale_fill_gradient(low = "yellow", high="red") +
  ggplot2::theme_bw() +
  ggplot2::geom_point(data = as.data.frame(sites),
                      ggplot2::aes(x = coords.x1, y = coords.x2), shape=21, size=2, 
                      colour = "white", fill= "black", alpha=1/2)
```

## Optimally Describing Isolines

On the basis of the kriging results we will create isolines and we will select an "Optimally Describing Isoline" (ODI) out of these. The selection of the ODI is based upon several statistical parameters of the isolines.

### Creating Contour Lines (Isolines)

In order to create isolines we need to transform the output of the `gstat::krige()` function, which is a raster, into `SpatialPolygonsDataFrame`. These have the advantage that statistics like the number of archaeological sites in an isoline can easily be calculated. One disadvantage is, that this transformation does take time.  
A fast way of this working step is to transform the raster first into a `SpatialGridDataFrame` and afterwards to use the function `inlmisc::Grid2Polygons()`:

```{r creating polygons}
isoline_polygons <- LEC_kriged %>%
  {raster::rasterFromXYZ(data.frame(x = sp::coordinates(.)[, 1],
                                  y = sp::coordinates(.)[, 2],
                                  z = .[[1]]),
                         crs = sites@proj4string)} %>%
  as("SpatialGridDataFrame") %>%
  inlmisc::Grid2Polygons(level = TRUE, at = seq(0, 20000, 500))

# This is not a reprojection!
sp::proj4string(isoline_polygons) <- sp::CRS("+init=epsg:31467")
```

Additionally, we have to rename the isoline_polygons, because the function `inlmisc::Grid2Polygons()` does name them with the middle value of each step, e.g. 1750 instead of 2000 in current example.

```{r renaming polygons}
# Rename the isolines because Grid2Polygon names them with the middle value
isoline_polygons@data[, 1] <- seq(0, 20000, 500)[2:c(length(isoline_polygons@data[, 1])+1)]
```



### Calculating the Area and Number of Sites per Isoline

### Selecting the "Optimally Describing Isoline"

## Data Export

## Bibliography

Hengel, T., **2007**. A Practical Guide to Geostatistical Mapping of Environmental Variables. (Uxembourg 2007).

Preuss, J. (ed.), **1998**. Das Neolithikum in Mitteleuropa: Kulturen, Wirtschaft, Umwelt vom 6. bis 3. Jahrtausend v. u. Z., Übersichten zum Stand der Forschung (Weissbach 1998).

Schmidt, I., Hilpert, J., Kretschmer, I., Peters, R., Broich, M., Schiesberg, S., Vogels, O., Wendt, K. P., Zimmermann, A., Maier, A., **accepted**. Approaching Prehistoric Demography: Proxies, Scales and Scope of the Cologne Protocol in European contexts. _Philosophical Transactions B_.

Zimmermann, A., Richter, J., Frank, T., Wendt, K.P., **2004**. Landschaftsarchäologie II. Überlegungen zu Prinzipien einer Landschaftsarchäologie. *Bericht der Römisch-Germanischen Kommission 85, 2004, 37-96*.

